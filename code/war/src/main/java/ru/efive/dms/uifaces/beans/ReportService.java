package ru.efive.dms.uifaces.beans;

import com.typesafe.config.Config;
import net.sf.jasperreports.engine.*;
import net.sf.jasperreports.engine.export.JRPdfExporter;
import net.sf.jasperreports.engine.query.JRHibernateQueryExecuterFactory;
import net.sf.jasperreports.engine.query.JRJpaQueryExecuterFactory;
import net.sf.jasperreports.export.SimpleExporterInput;
import net.sf.jasperreports.export.SimpleOutputStreamExporterOutput;
import net.sf.jasperreports.export.SimplePdfExporterConfiguration;
import org.hibernate.Session;
import org.hibernate.jdbc.Work;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import ru.efive.dms.util.Utils;
import ru.efive.dms.util.message.MessageHolder;
import ru.efive.dms.util.message.MessageUtils;
import ru.entity.model.referenceBook.DocumentForm;
import ru.entity.model.report.Report;
import ru.entity.model.user.User;
import ru.util.ApplicationHelper;

import javax.faces.context.FacesContext;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

@Service("reportService")
public class ReportService {
    private static final Logger log = LoggerFactory.getLogger(ReportService.class);
    private final Map<String, Object> defaultReportParameters;
    @PersistenceContext(unitName = ApplicationHelper.ORD_PERSISTENCE_UNIT_NAME)
    private EntityManager em;

    @Autowired
    public ReportService(@Qualifier("config") final Config config) {
        this.defaultReportParameters = Utils.getMapFromConfig(null, config.getConfig("report"));
        defaultReportParameters.forEach((key, value) -> log.info("DefaultReportParameter: '{}'={}", key, value));
    }


    public void fillAndShowReport(final Report report, final Map<String, Object> reportParameters) throws IOException {
        final JasperReport jasperReport;
        try {
            log.debug("Start loading template[{}]", report.getTemplateName());
            jasperReport = JasperCompileManager.compileReport(getClass().getResourceAsStream("/templates/" + report.getTemplateName()));
            log.info("Template loaded: {}", jasperReport.getName());
        } catch (JRException e) {
            log.error("Report[{}] '{}' error: Cannot compile template [{}]", report.getId(), report.getDisplayName(), report.getTemplateName(), e);
            MessageUtils.addMessage(MessageHolder.MSG_ERROR_ON_REPORT_COMPILATION, report.getDisplayName(), report.getTemplateName(), e.getMessage());
            return;
        }

        final Map<String, Object> parameters = new HashMap<>(defaultReportParameters);
        parameters.putAll(convertToReportObjectTypes(reportParameters));
        parameters.forEach((key, value) -> log.info("Report[{}]: '{}'={}", report.getTemplateName(), key, value));

        em.unwrap(Session.class).doWork(connection -> {
            try {
                final JasperPrint jasperPrint = JasperFillManager.fillReport(jasperReport, parameters, connection);
                HttpServletResponse response = (HttpServletResponse) FacesContext.getCurrentInstance().getExternalContext().getResponse();
                //Set reponse content type
                response.setContentType("application/pdf");
                //Export PDF file to browser window
                JRPdfExporter exporter = new JRPdfExporter();
                exporter.setExporterInput(new SimpleExporterInput(jasperPrint));
                exporter.setExporterOutput(new SimpleOutputStreamExporterOutput(response.getOutputStream()));
                SimplePdfExporterConfiguration configuration = new SimplePdfExporterConfiguration();
                configuration.setMetadataAuthor("ORD Autogenerated trought Jasperreports");  //why not set some config as we like
                configuration.setMetadataTitle(report.getDisplayName());
                exporter.setConfiguration(configuration);
                try {
                    exporter.exportReport();
                } catch (JRException e) {
                    log.error("Report[{}] '{}' error: Cannot fill template [{}]", report.getId(), report.getDisplayName(), report.getTemplateName(), e);
                    MessageUtils.addMessage(MessageHolder.MSG_ERROR_ON_REPORT_EXPORT, report.getDisplayName(), e.getMessage());
                }
            } catch (JRException | IOException e) {
                log.error("Report[{}] '{}' error: Cannot fill template [{}]", report.getId(), report.getDisplayName(), report.getTemplateName(), e);
                MessageUtils.addMessage(MessageHolder.MSG_ERROR_ON_REPORT_EXECUTION, report.getDisplayName(), e.getMessage());
            }
        });
    }

    private Map<String, Object> convertToReportObjectTypes(Map<String, Object> reportParameters) {
        final Map<String, Object> result = new HashMap<>(reportParameters.size());
        reportParameters.forEach((key, value) -> {
            if (value instanceof User) {
                result.put(key, ((User) value).getId());
            } else if (value instanceof DocumentForm) {
                result.put(key, ((DocumentForm) value).getCode());
            } else {
                result.put(key, value);
            }
        });
        return result;
    }
}